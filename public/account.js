/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@highfidelity/accounts/src/accounts.js":
/*!*************************************************************!*\
  !*** ./node_modules/@highfidelity/accounts/src/accounts.js ***!
  \*************************************************************/
/*! exports provided: EnergyMeter, RegistrationStatus, UserData, getFace, abandonFace, register, unregister, logIn, logOut, createInvite, purchase, getUpdatedCredentials, updateUserStats, configure, browserHasPasswordCredentialStore */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"register\", function() { return register; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unregister\", function() { return unregister; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"logIn\", function() { return logIn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"logOut\", function() { return logOut; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createInvite\", function() { return createInvite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"purchase\", function() { return purchase; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getUpdatedCredentials\", function() { return getUpdatedCredentials; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateUserStats\", function() { return updateUserStats; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"configure\", function() { return configure; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"browserHasPasswordCredentialStore\", function() { return browserHasPasswordCredentialStore; });\n/* harmony import */ var _browser_storage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browser-storage.js */ \"./node_modules/@highfidelity/accounts/src/browser-storage.js\");\n/* harmony import */ var _service_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./service.js */ \"./node_modules/@highfidelity/accounts/src/service.js\");\n/* harmony import */ var _user_data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./user-data.js */ \"./node_modules/@highfidelity/accounts/src/user-data.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"UserData\", function() { return _user_data_js__WEBPACK_IMPORTED_MODULE_2__[\"UserData\"]; });\n\n/* harmony import */ var _credits_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./credits.js */ \"./node_modules/@highfidelity/accounts/src/credits.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EnergyMeter\", function() { return _credits_js__WEBPACK_IMPORTED_MODULE_3__[\"EnergyMeter\"]; });\n\n/* harmony import */ var _registration_status_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./registration-status.js */ \"./node_modules/@highfidelity/accounts/src/registration-status.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RegistrationStatus\", function() { return _registration_status_js__WEBPACK_IMPORTED_MODULE_4__[\"RegistrationStatus\"]; });\n\n/* harmony import */ var _face_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./face.js */ \"./node_modules/@highfidelity/accounts/src/face.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getFace\", function() { return _face_js__WEBPACK_IMPORTED_MODULE_5__[\"getFace\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"abandonFace\", function() { return _face_js__WEBPACK_IMPORTED_MODULE_5__[\"abandonFace\"]; });\n\n\n\n\n\n\n\n\n\nfunction register(options) {\n    // FIXME: don't submit what has not actually changed.\n    return createOrUpdateRegistration(options)\n        .then(handleSuccessfulLogin);\n}\nasync function unregister(credential, localOnly = false) {\n    const id = credential.id;\n    return (localOnly ? Promise.resolve() : Object(_service_js__WEBPACK_IMPORTED_MODULE_1__[\"service\"])(ACCOUNTS + '/delete', credential))\n    // We cannot delete from browser credentials, but we can render them obvious.\n        .then(_ => deleteCredential(id))\n        .then(_ => Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"removeDb\"])(id))\n        .then(_ => Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"setDb\"])('ids', Object(_user_data_js__WEBPACK_IMPORTED_MODULE_2__[\"getIds\"])().filter(e => e !== id)))\n        .then(_ => {\n            const unregistered = Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"getDb\"])(unregisteredKey);\n            unregistered && (id === unregistered.id) && Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"removeDb\"])(unregisteredKey);\n        })\n        .catch(console.error)\n        .then(_ => !localOnly && logOut({preventSilentAccess: true}))\n}\n\nfunction logIn() { // case 1, above, followed by handleLoginResults\n    /*\n    return getCredential({\n        password: true,\n        mediation: \"optional\"\n        })*/\n\n    var ids = Object(_user_data_js__WEBPACK_IMPORTED_MODULE_2__[\"getIds\"])(), id = ids && ids[0], c = id && Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"getDb\"])(id);    \n    if (id) {\n        c.id = id;\n        if (Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"getDb\"])(PREVENT_SILENT_KEY)) {\n            delete c.password;\n        }\n    }\n    return Promise.resolve(c)\n        .then(c => c ? passwordLogin(c) : unregisteredLogin())\n        .then(handleLoginResult);\n}\nfunction logOut({preventSilentAccess} = {preventSilentAccess: true}) {\n    var newCredentials\n    return unregisteredLogin()\n        .then(handleSuccessfulLogin)\n        .then(c => newCredentials = c)\n        .then(_ => preventSilentAccess && preventSilentCredentialAccess())\n        .then(_ => newCredentials)\n}\n\nfunction createInvite(credential) {\n    return Object(_service_js__WEBPACK_IMPORTED_MODULE_1__[\"service\"])(ACCOUNTS + '/createInvite', credential).then(link => link.href);\n}\nfunction purchase(credential, credits) {\n    credential.purchase = credits;\n    return Object(_service_js__WEBPACK_IMPORTED_MODULE_1__[\"service\"])(ACCOUNTS + '/purchase', credential).then(_ => {\n        _credits_js__WEBPACK_IMPORTED_MODULE_3__[\"EnergyMeter\"].instance.tick(-credits, true);\n    });\n}\n\n// Resolves to the latest credentials, including password.\n// If putativeCredentials is empty, resolves immediately to nothing. (It does not logOut!)\n// Otherwise, the putativeCredentials are examined for {id, password}.\n// If id is falsy, resolves with the saved credential for the guest user on this device.\n// If id is truthy, it must be a registered id (an email), and it is sent to the server with password for\n// confirmation, possibly rejecting.\n// If login is succesful, resolves with the other info (name and iconURL) from the server.\n// The UI callbacks from RegistrationStatus may be invoked (if necessary due to changes, or even if\n// not needed).\nfunction getUpdatedCredentials(putativeCredentials) {\n    if (!putativeCredentials) return Promise.resolve();\n    const {id, password} = putativeCredentials;\n    return password\n        ? passwordLogin({id, password}).then(handleLoginResult).then(cred => Object.assign({password}, cred))\n    : unregisteredLogin().then(handleSuccessfulLogin);\n}\n\n// TODO: don't export after we get rid of fixmeDemoFollowId\nfunction updateUserStats(data) {\n    return Object(_service_js__WEBPACK_IMPORTED_MODULE_1__[\"service\"])(ACCOUNTS + '/updateUserStats', data).then(updated => {\n        const meter = _credits_js__WEBPACK_IMPORTED_MODULE_3__[\"EnergyMeter\"].instance;\n        // Let the meter know (e.g., if this call didn't originate with the meter).\n        if (meter) meter.currentEnergy = updated.credits;\n        return updated;\n    });\n}\n\n\nvar ACCOUNTS;\nfunction configure({\n    onRegistrationStatusChange, onUserData,\n    updateEnergyDisplay, getConsumption,\n    accountsUrl, modelsUrl = new URL('/models', accountsUrl).href\n}) {\n    _registration_status_js__WEBPACK_IMPORTED_MODULE_4__[\"RegistrationStatus\"].onRegistrationStatusChange = onRegistrationStatusChange;\n    _registration_status_js__WEBPACK_IMPORTED_MODULE_4__[\"RegistrationStatus\"].onUserData = onUserData;\n    _credits_js__WEBPACK_IMPORTED_MODULE_3__[\"EnergyMeter\"].onTick = updateEnergyDisplay;\n    _credits_js__WEBPACK_IMPORTED_MODULE_3__[\"EnergyMeter\"].getConsumption = getConsumption;\n    ACCOUNTS = accountsUrl;\n    Object(_face_js__WEBPACK_IMPORTED_MODULE_5__[\"configure\"])({modelsUrl});\n    return Promise.resolve(); // Promise for future-proofing\n}\n\n// The PasswordCredential API is not implemented in Safari or Firefox yet.\n// This uses the API when available, otherwise we recreate the same API, with similar UI.\nfunction browserHasPasswordCredentialStore() {\n    return false; // FIXME: for now, let's lean on our home-grown stuff so that it gets excercised.\n    //return 'PasswordCredential' in window;  // Seems to be true just for Chrome.\n}\nconst DELETED_CREDENTIAL_PROPERTY_VALUE = 'deleted';\nfunction deleteCredential(id) {\n    setCredential({id, password: DELETED_CREDENTIAL_PROPERTY_VALUE,\n                   name: DELETED_CREDENTIAL_PROPERTY_VALUE});\n}\nconst dbVersion = 13;\nvar version = Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"getDb\"])('version');\nif (version && (version < dbVersion)) {\n    alert('Clearing local db. You should probably clear your browser passwords for https://web-connections.herokuapp.com before proceeding! (E.g., chrome://settings/passwords and look for web-connection.herokuapp - Ask Howard.)');\n    if (browserHasPasswordCredentialStore()) {\n        Object(_user_data_js__WEBPACK_IMPORTED_MODULE_2__[\"getIds\"])().forEach(deleteCredential);\n    }\n    localStorage.clear();\n    Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"setDb\"])('version', dbVersion);\n} else if (!version) {\n    Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"setDb\"])('version', dbVersion);\n}\n\n\nfunction setCredential(credential) {\n    if (browserHasPasswordCredentialStore()) {\n        // The spec (and mozilla.org) says the following,\n        // but the W3C examples say new PasswordCredential(options). Old?\n        // Anyway, testing for the existence of the PasswordCredential class seems to work.\n        return navigator.credentials\n            .create({password: credential})\n            .then(cred => navigator.credentials.store(cred));\n    } // Fake our own.\n    if (!credential.password) {\n        return Promise.reject(`Unsupported credential options: ${JSON.stringify(credential)}.`);\n    }\n    // The caller, storeCredentials, has saved id, name, and iconURL. For now, we also save\n    // password here, for use with STORE_PASSWORDS true. FIXME: if we decide to use the\n    // STORE_PASSWORDS false case, this line should be removed.\n    Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"setDbSubkey\"])(credential.id, 'password', credential.password); // see fixme in getCredential\n    return Promise.resolve();\n}\n\n// We want to account for energy of everybody, so everyone logs in in some way.\n// An unregistered user still needs a login, but it is handled somewhat differently.\n// There are (at least) two ways we could handle this:\n// 1) Have an explicit path through unregisteredLogin, which creates the insecure acount here\n//    and then continues to use those same credentials for any subsequent unregistered use.\n// 2) Use the getCredential account machinery in the normal way, tracking the registered account\n//    and the \"anonymous\" one.\n// We're doing (1) while things are in such flux. Let's see how it goes.\n\nconst unregisteredKey = 'unregistered';\nfunction getUnregisteredCredentials() {\n    return Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"getDb\"])(unregisteredKey) || {}; // If empty, /login will generate a new one for us to store and re-use.\n}\nfunction setUnregisteredCredentials(credentials) {\n    const {id, name, iconURL} = credentials;\n    Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"setDb\"])(unregisteredKey, {id, name, iconURL});\n    return Promise.resolve();\n}\nfunction preservingId(newId, promiseThunk) { // TODO: re-think this.\n    const old = _registration_status_js__WEBPACK_IMPORTED_MODULE_4__[\"RegistrationStatus\"].id();\n    _registration_status_js__WEBPACK_IMPORTED_MODULE_4__[\"RegistrationStatus\"].now(newId);\n    return promiseThunk().catch(e => {\n        _registration_status_js__WEBPACK_IMPORTED_MODULE_4__[\"RegistrationStatus\"].now(old);\n        return Promise.reject(e);\n    });\n}\nfunction unregisteredLogin() {\n    // FIXME: do we have what we need in cookies? Do we need to contact the server again?\n    return preservingId(false, _ => {\n        const credentials = Object.assign({}, getUnregisteredCredentials());\n        _registration_status_js__WEBPACK_IMPORTED_MODULE_4__[\"RegistrationStatus\"].addPendingInviteToCredentials(credentials);\n        return Object(_service_js__WEBPACK_IMPORTED_MODULE_1__[\"service\"])(ACCOUNTS + '/login', credentials, {  // UI should still work on failure.\n            iconURL: \"images/anonymous.jpg\",\n            name: \"anonymous\"\n        });\n    });\n}\n// The data sent to /login is {id, password, destination}, with the latter optional.\n// The result is merged against any other supplied defaults from credential (so that the server doesn't HAVE to send them back unless changed).\nfunction passwordLogin(credential) {\n    const {id, password} = credential, data = {id, password};\n    return preservingId(id, _ => {\n        _registration_status_js__WEBPACK_IMPORTED_MODULE_4__[\"RegistrationStatus\"].addPendingInviteToCredentials(data);\n        return Object(_service_js__WEBPACK_IMPORTED_MODULE_1__[\"service\"])(ACCOUNTS + '/login', data, credential);\n    });\n}\n// All of the given options are passed to /registration:\n//   New registrations should include {id, password, name, iconURL, strength}.\n//   Updates must have an oldEmail|id and an oldPassword|password that matches previous registration.\n// The result is merged against defaults from options (so that the serve doesn't HAVE to send them back unless changed).\nfunction createOrUpdateRegistration(options) { // on server\n    return preservingId(options.password && options.id, _ => {\n        const data = Object.assign({}, options);\n        _registration_status_js__WEBPACK_IMPORTED_MODULE_4__[\"RegistrationStatus\"].addPendingInviteToCredentials(data);\n        return Object(_service_js__WEBPACK_IMPORTED_MODULE_1__[\"service\"])(ACCOUNTS + '/registration', data, options);\n    });\n}\n\nfunction canonicalizeUserData(user) {\n    // Make note of changes, side effecting user so that new values are in the right properties for storage.\n    // Also gives us a chance to log changes or tell the user.\n    function last(list) { return list && list[list.length - 1]; }\n    let changes = [],\n        email = last(user.emails),\n        face = last(user.faces);\n    function noteNew(newValue, key, label = key) {\n        if (newValue && (newValue !== user[key])) {\n            if (label) changes.push(label);\n            user[key] = newValue;\n            return true;\n        }\n    }\n    if (noteNew(email, 'id', 'email')) Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"removeDb\"])(user.id); // storeCredentials will restore.\n    noteNew(user.displayName, 'name');\n    noteNew(face, 'iconURL', 'security selfie');\n    if (user.iconURL && !user.iconURL.startsWith('data:')) {\n        user.iconURL = new URL(user.iconURL, location.href).href;\n    }\n    // We can't make note of a new password, and we don't need to.    \n    if ((user.credits - _credits_js__WEBPACK_IMPORTED_MODULE_3__[\"EnergyMeter\"].instance.currentEnergy) > 1) changes.push('credits'); // FIXME: but is it worthy notifying user?\n    return [user, changes];\n}\n\n// FIXME: should be randomized a bit to avoid synchronization\nfunction reportUserStats(credits) {\n    const status = _registration_status_js__WEBPACK_IMPORTED_MODULE_4__[\"RegistrationStatus\"].instance;\n    const data = {\n        id: status.registeredId || getUnregisteredCredentials().id,\n        location: status.mapLocation,\n        energy: credits\n    };\n    updateUserStats(data);\n}\n\n// In the user object that comes back from the server:\n// Any value returned for displayName, password, iconURL, strength, credits, x, y is current. (Perhaps updated from another machine.)\nfunction handleSuccessfulLogin(user) {\n    if (!user) return Promise.resolve();\n    const registered = user.password; // No need for passwords on unregistered \"accounts\".\n    _credits_js__WEBPACK_IMPORTED_MODULE_3__[\"EnergyMeter\"].run({\n        stipend: registered ? _credits_js__WEBPACK_IMPORTED_MODULE_3__[\"STIPEND_PER_DAY\"] : 0,\n        credits: user.credits || 0,\n        reporter: reportUserStats\n    });\n    // Side-effect to user (e.g., by canonicalizeUserData) are generally done on the object rather than replacing the object,\n    // but assignment to user allows the possibility of whole-scale replacement.\n    var [userData, changes] = canonicalizeUserData(user);\n    userData = _registration_status_js__WEBPACK_IMPORTED_MODULE_4__[\"RegistrationStatus\"].instance.processUserData(userData, changes);\n    const stored = registered ? storeCredentials(userData) : setUnregisteredCredentials(userData);\n    if (user.password) Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"setDb\"])(PREVENT_SILENT_KEY, false);\n    return stored.then(_ => userData);\n}\nfunction storeLocalCredential(credential) {\n    Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"setDbSubkey\"])(credential.id, 'iconURL', credential.iconURL);\n    Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"setDbSubkey\"])(credential.id, 'name', credential.name);\n    Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"pushDbIfNew\"])('ids', credential.id);\n}\nfunction storeCredentials(options) {\n    // We don't get to ask navigator.credentials how many accounts there are, or what their names/icons are,\n    // so store them ourselves as well.\n    storeLocalCredential(options);\n    return setCredential(options);\n}\n\nfunction handleLoginResult(result) {\n    if (result) return handleSuccessfulLogin(result);\n    return logOut({preventSilentAccess: false});\n}\n\nconst PREVENT_SILENT_KEY = 'preventSilentAccess';\nasync function getCredential(options) {\n    if (browserHasPasswordCredentialStore()) {\n        const start = Date.now();\n        return navigator.credentials.get(options)\n            .then(cred => {\n                const elapsed = Date.now() - start;\n                if (elapsed > 50) return cred; // explicit user action: believe the user\n                if (cred) return cred;\n                const ids = Object(_user_data_js__WEBPACK_IMPORTED_MODULE_2__[\"getIds\"])();\n                if (ids.length) { // There should have been choices for the user. Must be opting out of browser store\n                    return gatherCredentialWithPassword(ids);\n                }\n                return;\n            })\n            .then(filterDeletedCredential)\n            .then(reconcileLocalStorage);\n    } // Fake our own.\n    if (!options.password || options.mediation !== \"optional\") {\n        return Promise.reject(`Unsupported credential options: ${JSON.stringify(options)}.`);\n    }\n    var availableIdentities = Object(_user_data_js__WEBPACK_IMPORTED_MODULE_2__[\"getIds\"])(),\n        force = Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"getDb\"])(PREVENT_SILENT_KEY),\n        credential = await gatherCredentialWithPassword(availableIdentities,\n                                                        {forceDialog: force});\n    if (credential) {\n        Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"setDb\"])(PREVENT_SILENT_KEY, false);\n        credential.type = 'password';\n        return credential;\n    }\n}\nfunction preventSilentCredentialAccess() {\n    if (browserHasPasswordCredentialStore()) {\n        return navigator.credentials.preventSilentAccess();\n    }\n    Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"setDb\"])(PREVENT_SILENT_KEY, true);\n    return Promise.resolve();\n}\n\n\n//# sourceURL=webpack:///./node_modules/@highfidelity/accounts/src/accounts.js?");

/***/ }),

/***/ "./node_modules/@highfidelity/accounts/src/browser-storage.js":
/*!********************************************************************!*\
  !*** ./node_modules/@highfidelity/accounts/src/browser-storage.js ***!
  \********************************************************************/
/*! exports provided: getDb, removeDb, setDb, setDbSubkey, pushDbIfNew */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDb\", function() { return getDb; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeDb\", function() { return removeDb; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setDb\", function() { return setDb; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setDbSubkey\", function() { return setDbSubkey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pushDbIfNew\", function() { return pushDbIfNew; });\nfunction getDb(key) {\n    const value = localStorage.getItem(key); // FIXME use indexedDB\n    if (value === undefined) return value;\n    return JSON.parse(value);\n}\nfunction removeDb(key) {\n    localStorage.removeItem(key);\n}\nfunction setDb(key, value) {\n    localStorage.setItem(key, JSON.stringify(value)); // FIXME use indexedDB\n}\nfunction setDbSubkey(key, subkey, value) {\n    const hash = getDb(key) || {};\n    hash[subkey] = value;\n    setDb(key, hash);\n}\nfunction pushDbIfNew(key, value) {\n    const array = getDb(key) || [];\n    if (array.includes(value)) return;\n    array.unshift(value); // New value first, because that's what we look at for \"the\" registered value\n    setDb(key, array);\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/@highfidelity/accounts/src/browser-storage.js?");

/***/ }),

/***/ "./node_modules/@highfidelity/accounts/src/credits.js":
/*!************************************************************!*\
  !*** ./node_modules/@highfidelity/accounts/src/credits.js ***!
  \************************************************************/
/*! exports provided: STIPEND_PER_DAY, EnergyMeter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STIPEND_PER_DAY\", function() { return STIPEND_PER_DAY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EnergyMeter\", function() { return EnergyMeter; });\n// FIXME: this section of code is identical to server. Should split into a module with webpack so that there's a single source.\nconst STIPEND_PER_DAY = 60;\nconst MILLISECONDS_PER_DAY = 24 * 60 * 60 * 1000;\nconst DECAY_PER_DAY = -0.075;\nconst DECAY_COMPOUNDINGS_PER_DAY = 1;\n\n// Given a principle ms ago, computes the current value compounding the decay and adding the stipend at end of compounding period.\nfunction computeCreditsOnInterval(principle, ms, dailyStipend = 0) {\n    const t = ms / MILLISECONDS_PER_DAY;\n    const rateAtCompounding = DECAY_PER_DAY / DECAY_COMPOUNDINGS_PER_DAY; // r/n in financial formulas\n    const nCompoundings = DECAY_COMPOUNDINGS_PER_DAY * t;                // n*t in financial formulas\n    const compoundGrowth = Math.pow(1 + rateAtCompounding, nCompoundings); // (1 + r/n)^(nt)\n    const compoundInterestForPrinciple = principle * compoundGrowth;\n    const futureValueOfASeries = dailyStipend * (compoundGrowth - 1) / rateAtCompounding;\n    return compoundInterestForPrinciple + futureValueOfASeries;\n}\n// End of identical section\n\nclass WindowedAverage {\n    constructor(size) {\n        this.array = Array(size).fill(0);\n    }\n    getAverage() {\n        return this.array.reduce((acc, amount) => acc + amount, 0) / this.array.length;\n    }\n    windowedAverage(amount) {\n        this.array.shift(); // TODO: use Queue?\n        this.array.push(amount);\n        return this.getAverage();\n    }\n}\n\nclass EnergyMeter {\n    static run({  // Creates a new singleton instance on a timer.\n        credits = 0,\n        stipend = 0,\n        // You EITHER have multiple instances on which you explicitly call tick,\n        // OR you can run a singleton on a timer that calls getConsumption() for a value over the last interval.\n        getConsumption = this.getConsumption,\n        tickIntervalMs = 100,\n        // ontick is called each tick with windowed averages of consumption and of energy.\n        onTick = this.onTick,\n        window = 5, // number of ticks in consumption windowed average\n        ramp = 1000 / tickIntervalMs, // energy windowed average is window * ramp\n        reporter,  // To phone home with authoritive info.\n        reportInterval = 15 * 1000  // Can be set to Infinity to allow explicitly demanded reporting without intermittent updates.\n    }) {\n        clearInterval(this.running);\n        const instance = new this({credits, stipend, window, ramp, onTick, reporter, reportInterval});\n        if (getConsumption) {\n            let onInterval = _ => instance.tick(getConsumption());\n            this.running = setInterval(onInterval, tickIntervalMs);\n            this.instance = instance;\n        }\n        return instance;\n    }\n    constructor({credits, stipend, onTick, window, ramp, reporter, reportInterval}) {\n        this.currentEnergy = credits;\n        this.lastUpdate = Date.now();\n        this.stipend = stipend;\n        this.onTick = onTick;\n        this.consumptionBuffer = new WindowedAverage(window);\n        this.energyBuffer = new WindowedAverage(window * ramp);\n        this.reporter = reporter;\n        this.reportInterval = reportInterval;\n        this.resetReporter();\n    }\n    static resetReporter(interval) {\n        const instance = this.instance;\n        if (!instance) return;\n        instance.resetReporter(interval);\n    }\n    resetReporter(reportInterval = this.reportInterval) {\n        if (!this.reporter) return;\n        this.nextReport = this.lastUpdate + reportInterval;\n    }\n    // It isn't quite accurate to just decrement currentEnergy. Instead,\n    // call tick(decrement). It's ok to do this even when a timer is going.\n    tick(consumptionThisPeriod, forceReport = false) {\n        const now = Date.now(),\n              elapsed = now - this.lastUpdate;\n        this.lastUpdate = now;\n        const energy = this.currentEnergy = Math.max(0, computeCreditsOnInterval(this.currentEnergy, elapsed, this.stipend)\n                                                     - consumptionThisPeriod);\n        const onTick = this.onTick;\n        if (onTick) {\n            onTick(this.consumptionBuffer.windowedAverage(consumptionThisPeriod),\n                   this.energyBuffer.windowedAverage(energy));\n        }\n        const next = this.nextReport;\n        if (next && (forceReport || (now >= next))) {\n            this.resetReporter();\n            this.reporter(energy);\n        }\n    }\n}\nwindow.EnergyMeter = EnergyMeter; // For debugging.\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@highfidelity/accounts/src/credits.js?");

/***/ }),

/***/ "./node_modules/@highfidelity/accounts/src/face.js":
/*!*********************************************************!*\
  !*** ./node_modules/@highfidelity/accounts/src/face.js ***!
  \*********************************************************/
/*! exports provided: configure, getFace, abandonFace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"configure\", function() { return configure; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFace\", function() { return getFace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"abandonFace\", function() { return abandonFace; });\n// Gives an alert (but does not current reject) if a promise takes more than timeoutMS to resolve. Also logs execution time.\nfunction withTimeout(label, promise, timeoutMs = 5000) {\n    const start = Date.now();\n    const timeout = setTimeout(_ => alert(`Debug: timeout during ${label}.`), timeoutMs);\n    return promise.then(result => {\n        clearTimeout(timeout);\n        console.log(label, Date.now() - start);\n        return result;\n    });\n}\n\nfunction delay(ms) { // Answer a promise that resolves after the specified ms.\n    return new Promise(resolve => setTimeout(_ => resolve(), ms));\n}\n\nfunction speak(text) {\n    var utterThis = new SpeechSynthesisUtterance(text);\n    function onError(event) {\n        alert(`Error while telling you \"${text}\": ${event.error}`);\n    }\n    utterThis.onerror = onError;\n    utterThis.volume = 1;\n    speechSynthesis.speak(utterThis);\n}\n\nvar faceApiLoad = withTimeout('api load', new Promise(resolve => {\n    if (faceapi && faceapi.nets) {\n        resolve();\n    } else {\n        faceApi.onload = _ => resolve();\n    }\n}));\nvar models;\nfunction configure({modelsUrl = '/models'}) {\n    return models = faceApiLoad.then(_ => withTimeout('load models', Promise.all([\n        //faceapi.nets.ssdMobilenetv1.loadFromUri(modelsUrl),\n        faceapi.nets.tinyFaceDetector.loadFromUri(modelsUrl),\n        faceapi.nets.faceLandmark68TinyNet.loadFromUri(modelsUrl),\n        faceapi.nets.faceRecognitionNet.loadFromUri(modelsUrl),\n        faceapi.nets.faceExpressionNet.loadFromUri(modelsUrl)\n    ]), 10 * 1000));\n}\n\nvar webcamVideo, videoOverlay; // TODO: just take an empty div and make (and style) our own\nvar alreadyAbandoned = false;\n\n// Promise a dataUrl of a face. Can be abandoned (resolving to falsy) by abandonFace().\nfunction getFace(video, overlay) {\n    alreadyAbandoned = false;    \n    webcamVideo = video;\n    videoOverlay = overlay;\n    videoOverlay.getContext('2d').clearRect(0, 0, videoOverlay.width, videoOverlay.height);\n    speak(\"Let's go.\");\n    return withTimeout('webcam access', Promise.all([\n        // Get camera AND load models before we try to capture.\n        navigator.mediaDevices.getUserMedia({video: true})\n            .then(stream => new Promise(resolve => {\n                webcamVideo.srcObject = stream;\n                webcamVideo.onloadedmetadata = _ => resolve(stream);\n            }))\n            .catch(e => alert('Unable to access to Webcam!')),\n        models\n    ]), 10 * 1000).then(_ => {\n        models = null; // Won't actually get gc'd while face.api is using it, but we're living clean here.\n        lastInstruction = '';\n        captured = gotNeutral = gotExpression = gotFail = descriptor = false;\n        return webcamCapture({ width: webcamVideo.offsetWidth, height: webcamVideo.offsetHeight }, Date.now());\n    });\n}\n\nfunction abandonFace() {\n    webcamStop(false);\n}\n\nfunction webcamStop(success) {\n    if (alreadyAbandoned) return;\n    if (webcamVideo.srcObject) {\n        webcamVideo.srcObject.getTracks().forEach(track => track.stop());\n        webcamVideo.srcObject = null;\n        if (success) speak(\"Thank you. Data for proof of unique human is complete\");\n    }\n    alreadyAbandoned = true;\n}\n\nfunction bestFace(detections) { // Return the highest scoring face from dections array.\n    if (detections.length <= 1) return detections[0];\n    const review = review.concat(); // copy\n    review.sort((a, b) => Math.sign(b.detection.score - a.detection.score)); // highest score first.\n    return review[0];\n}\n\nfunction findFaces(displaySize) {\n    var groupResult, resizedDetections;\n    return withTimeout('computing face', new Promise(async resolve => {\n        try {\n            groupResult = await faceapi.detectAllFaces(webcamVideo, new faceapi.TinyFaceDetectorOptions({inputSize: 128}))\n                .withFaceLandmarks(true)\n                .withFaceDescriptors()\n                .withFaceExpressions();\n            faceapi.matchDimensions(videoOverlay, displaySize); // Clears overlay, so it has to be done each loop\n            resizedDetections = faceapi.resizeResults(groupResult, displaySize);\n            faceapi.draw.drawDetections(videoOverlay, resizedDetections);\n            faceapi.draw.drawFaceExpressions(videoOverlay, resizedDetections, 0.05);\n        } catch (e) {\n            alert(`Error in computing faces: ${e.message || e}`);\n        }\n        resolve([bestFace(resizedDetections), groupResult]);\n    }));\n}\n\n// Expressed in horizontal dimensions, but works for height, too, of course.\nfunction reDimension(left, width, frameWidth, margin) {\n    const fixmeLeft = left, fixmeWidth = width;\n    const center = left + (width / 2);\n    width += (2 * margin);\n    left = Math.max(0, center - (width / 2));\n    const right = Math.min(frameWidth, center + (width / 2));\n    width = right - left;\n    return [left, width];\n}\n\n\nvar lastInstruction = '', gotNeutral = false, gotExpression = false, gotFail = false, descriptor = false;\nvar captured;\nasync function webcamCapture(displaySize, start) {\n    if (alreadyAbandoned) return '';\n    const [face, raw] = await findFaces(displaySize);\n    if (alreadyAbandoned) return '';\n    const now = Date.now(), TIMEOUT_MS = 2000;\n    var instruction = '';\n    function expired(expires) { return expires && (now > expires); }\n    if (face) {\n        const box = face.detection.box;\n        const margin = 10;\n        if (displaySize.height < displaySize.width\n            ? (box.height < displaySize.height / 2)\n            : (box.width < displaySize.width / 2)) {\n            instruction = \"Move closer, please\";\n        } else if (box.left < margin) {\n            instruction = \"Move left\";\n        } else if (box.top < margin) {\n            instruction = \"Move down\";\n        } else if (box.right > displaySize.width - margin) {\n            instruction = \"Move right\";\n        } else if (box.bottom > displaySize.height - margin) {\n            instruction = \"Move up\";\n        } else {\n            const expressions = face.expressions;\n            const MAX_DISTANCE = 0.4;\n            gotFail = false;\n            if (['happy', 'sad', 'angry', 'fearful', 'disgusted', 'surprised'].some(x => expressions[x] > 0.9)) {\n                if (!gotExpression) {\n                    var distance = 0;\n                    if (descriptor) {\n                        distance = faceapi.euclideanDistance(face.descriptor, descriptor);\n                        console.info('expression distance:', distance);\n                    } else {\n                        descriptor = face.descriptor;\n                    }\n                    if (distance > MAX_DISTANCE) {\n                        gotFail = now + TIMEOUT_MS;\n                    } else {\n                        gotExpression = now + TIMEOUT_MS;\n                    }\n                }\n            } else if (expressions.neutral > 0.9) {\n                if (!gotNeutral) {\n                    var distance = 0;\n                    if (descriptor) {\n                        distance = faceapi.euclideanDistance(face.descriptor, descriptor);\n                        console.info('neutral distance:', distance);\n                    } else {\n                        descriptor = face.descriptor;\n                    }\n                    if (distance > MAX_DISTANCE) {\n                        gotFail = now + TIMEOUT_MS;\n                    } else {\n                        gotNeutral = now + TIMEOUT_MS;\n                    }\n                }\n                if (!captured) {\n                    const bigBox = bestFace(raw).detection.box;\n                    const scaledMargin = margin * webcamVideo.videoWidth / displaySize.width;\n                    const [left, width] = reDimension(bigBox.left, bigBox.width, webcamVideo.videoWidth, scaledMargin);\n                    const [top, height] = reDimension(bigBox.top, bigBox.height, webcamVideo.videoHeight, scaledMargin);\n                    captured = document.createElement(\"canvas\");\n                    captured.width = width;\n                    captured.height = height;\n                    captured.getContext('2d').drawImage(webcamVideo,\n                                                        left, top, width, height,\n                                                        0, 0, width, height);\n                }\n            }\n        }\n    } else if (!gotFail) {\n        gotFail = now + TIMEOUT_MS;\n    }\n    if (expired(gotFail)) {\n        instruction = \"Make sure there is enough light, and that you can see your face with a box in the center of the video\";\n    }\n    if (instruction || gotFail) {\n        captured = gotNeutral = gotExpression = descriptor = false;\n        if (instruction) gotFail = false;\n    } else if (!gotExpression && expired(gotNeutral)) {\n        instruction = \"Please smile, or make a face\";\n    } else if (!gotNeutral && expired(gotExpression)) {\n        instruction = \"Please have a neutral expression\";\n    }\n\n    if (instruction && (instruction != lastInstruction) && !speechSynthesis.pending && !speechSynthesis.speaking) {\n        speak(instruction);\n        lastInstruction = instruction;\n    }\n    if (gotExpression && gotNeutral) {\n        webcamStop(true);\n        console.log('captured snap is', captured.width, 'x', captured.height);\n        return captured.toDataURL();\n    } else if (alreadyAbandoned) {\n        console.log(\"abandoned face\");\n        return '';\n    } else { // Throttled repeat\n        const INTENDED_MAX_INTERVAL_MS = 1000, MIN_MS = 100, elapsed = now - start;\n        console.log(elapsed, instruction, gotExpression, gotNeutral, gotFail);\n        return delay(Math.max(MIN_MS, INTENDED_MAX_INTERVAL_MS - elapsed))\n            .then(_ => webcamCapture(displaySize, now));\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/@highfidelity/accounts/src/face.js?");

/***/ }),

/***/ "./node_modules/@highfidelity/accounts/src/registration-status.js":
/*!************************************************************************!*\
  !*** ./node_modules/@highfidelity/accounts/src/registration-status.js ***!
  \************************************************************************/
/*! exports provided: RegistrationStatus, distance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RegistrationStatus\", function() { return RegistrationStatus; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\n/* harmony import */ var _credits_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./credits.js */ \"./node_modules/@highfidelity/accounts/src/credits.js\");\n/* harmony import */ var _user_data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./user-data.js */ \"./node_modules/@highfidelity/accounts/src/user-data.js\");\n\n\n\n// Models behavior regarding registration and invites.\n// Currently exposes registered id, but not credential info, and currently separate from EnergyMeter.\nclass RegistrationStatus {\n    static now(registeredIdOrFalsy) { // Creates a new instance IFF different\n        if (this.instance && (this.instance.registeredId === registeredIdOrFalsy)) return this.instance;\n        return this.instance = new this(registeredIdOrFalsy);\n    }\n    static id() {\n        const instance = this.instance;\n        return instance && instance.registeredId;\n    }\n    static destination() {\n        const instance = this.instance;\n        return instance && instance.destination;\n    }\n    static teleport(destination) {\n        const instance = this.instance;\n        return instance && instance.teleport(destination);\n    }\n    static setLocation(x, y) {\n        const instance = this.instance;\n        return instance && instance.setLocation(x, y);\n    }\n    static hasRegistered() {\n        return _user_data_js__WEBPACK_IMPORTED_MODULE_1__[\"UserData\"].hasRegistered();\n    }\n    static addPendingInviteToCredentials(credentials) { // Added BEFORE login.\n        const invite = new URL(location.href).searchParams.get('invite');\n        credentials.destination = invite;\n    }\n    constructor(registeredIdOrFalsy) {\n        this.registeredId = registeredIdOrFalsy;\n        this.mapLocation = {};\n        const onChange = RegistrationStatus.onRegistrationStatusChange;\n        if (onChange) onChange(registeredIdOrFalsy);\n        _credits_js__WEBPACK_IMPORTED_MODULE_0__[\"EnergyMeter\"].resetReporter();\n    }\n    processUserData(response, notedChanges) { // Consumed just AFTER login, passing a possibly modified response through onUserData.\n        var {x, y, destination} = response;\n        this.destination = null;\n        if (destination) {\n            delete response.destination;\n            if ((destination.x === undefined) || (destination.y === undefined)) {\n                ; //nothing\n            } else if (distance([x, y], [destination.x, destination.y]) < this.constructor.NEARBY) {\n                destination.reason = 'arrived';\n            } else { // hold on to the destination for later use by the ui\n                this.destination = destination;\n            }\n        }\n        this.setLocation(x, y, destination && !this.destination);\n        const onUserData = this.constructor.onUserData;\n        if (onUserData) return onUserData(response, destination, notedChanges);\n        return response;\n    }\n    setLocation(x, y, removeInvite = false) {\n        // Keep track (for saving in server).\n        // Updates url with x,y if class.trackLocationInURL.\n        // Strips invite from url if removeInvite.\n        if ((x === undefined) || (y === undefined)) return;\n        // We don't have a handle to \"the current credentials\". Here we maintain just the current x/y.\n        // Updates the server (e.g., reportUserStatus) grab mapLocation.\n        this.mapLocation.x = x;\n        this.mapLocation.y = y;\n        const urlInLocation = this.constructor.trackLocationInURL;\n        if (!urlInLocation && !removeInvite) return;\n        const params = new URL(location.href).searchParams;\n        if (urlInLocation) {\n            params.set('x', x);\n            params.set('y', y);\n        }\n        if (removeInvite) params.delete('invite');\n        history.replaceState({}, document.title, location.pathname + '?' + params + location.hash);\n    }\n    teleport(destination = this.destination) { // Go there and return true if possible, deducting cost and telling onUserData of arrival.\n        if (!destination) return;\n        const meter = _credits_js__WEBPACK_IMPORTED_MODULE_0__[\"EnergyMeter\"].instance;\n        const cost = 5;\n        if (meter.currentEnergy < cost) return;\n        const {x, y, name} = this.destination;\n        this.destination = null;\n        this.setLocation(x, y, true);\n        meter.tick(cost, true);\n        const onUserData = this.constructor.onUserData;\n        if (onUserData) onUserData({}, {reason: 'arrived', name});\n        return true;\n    }\n}\nRegistrationStatus.NEARBY = 100; // meters\nRegistrationStatus.trackLocationInURL = true;\nwindow.RegistrationStatus = RegistrationStatus; // For debugging.\n\nfunction distance(a, b, defaultValue = Infinity) { // euclidian distance between any two arrays\n    var sum = 0, dimensions = Math.max(a.length, b.length);\n    for (let i = 0; i < dimensions; i++) {\n        let [elementA = defaultValue, elementB = defaultValue] = [a[i], b[i]];\n        let difference = elementA - elementB;\n        sum += difference * difference;\n    }\n    return Math.sqrt(sum);\n}\n\n\n//# sourceURL=webpack:///./node_modules/@highfidelity/accounts/src/registration-status.js?");

/***/ }),

/***/ "./node_modules/@highfidelity/accounts/src/service.js":
/*!************************************************************!*\
  !*** ./node_modules/@highfidelity/accounts/src/service.js ***!
  \************************************************************/
/*! exports provided: serializePromises, asyncService, service */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"serializePromises\", function() { return serializePromises; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"asyncService\", function() { return asyncService; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"service\", function() { return service; });\n\n\nfunction trim(x) { // like inspect, but trimming long strings\n    const maxString = 60;\n    if (x === null) return \"null\";\n    if (typeof x === 'string') {\n        if (x.length > maxString) return `\"${x.slice(0, maxString)}...\"`;\n        return '\"' + x + '\"';\n    }\n    if (Array.isArray(x)) return '[' + x.map(trim).join(', ') + ']';\n    if (typeof x === 'object') return '{' + Object.keys(x).map(k => `${k}: ${trim(x[k])}`).join(', ') + '}';\n    return x;\n}\n\n// Takes a f(...args) => promise and returns a f(..args) that does so one a time.\nfunction serializePromises(make1Promise) {\n    let last = Promise.resolve();\n    return function (...args) {\n        last = last.catch(_ => _).then(_ => make1Promise(...args));\n        return last;\n    }\n}\n\nfunction asyncService(url, data, defaultProperties = {}) {\n    return fetch(url, {\n        method: 'post',\n        headers: {\n            'Accept': 'application/json',\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(data)\n    })\n        .then(response => response.json())\n        .then(json => {\n            const result = !json.error && Object.assign({}, defaultProperties, json);\n            console.log(url,\n                        '\\nsent:', data, //trim(data),\n                        '\\nreceived:', json, //trim(json),\n                        '\\nreturning:', result); //trim(result));\n            return json.error ? Promise.reject(new Error(json.error)) : result;\n        });\n}\n\n// Overlapping service calls are surely not intentional. E.g., /updateUserStats during /registration.\n// So, let's serialize 'em all - unless someone explicitly uses asyncService directly.\nconst service = serializePromises(asyncService);\n\n\n//# sourceURL=webpack:///./node_modules/@highfidelity/accounts/src/service.js?");

/***/ }),

/***/ "./node_modules/@highfidelity/accounts/src/user-data.js":
/*!**************************************************************!*\
  !*** ./node_modules/@highfidelity/accounts/src/user-data.js ***!
  \**************************************************************/
/*! exports provided: UserData, getIds */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UserData\", function() { return UserData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getIds\", function() { return getIds; });\n/* harmony import */ var _browser_storage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browser-storage.js */ \"./node_modules/@highfidelity/accounts/src/browser-storage.js\");\n\nclass UserData {\n    static hasRegistered() {\n        return getIds()[0];\n    }\n    static getIds() {  // for now\n        return getIds();\n    }\n    static getCredential(id) { // for now\n        return Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"getDb\"])(id);\n    }\n    static storeCredential(credential) {\n        return storeLocalCredential(credential);\n    }\n}\n\nfunction getIds() {\n    return Object(_browser_storage_js__WEBPACK_IMPORTED_MODULE_0__[\"getDb\"])('ids') || [];\n}\n\n\n//# sourceURL=webpack:///./node_modules/@highfidelity/accounts/src/user-data.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @highfidelity/accounts */ \"./node_modules/@highfidelity/accounts/src/accounts.js\");\n\n\n/* This file has the following sections (which could, of course, be split into multiple files).\n   APPLICATION LOGIC - independent of the UI\n   UI LOGIC          - references UI elements (e.g., defined by id in the .html), other than that done by Face Logic\n   GLOBALS           - UI constants whose initialization would be different with webpack, etc.\n   UI INITIALIZATION - MDC object instantiation, and setting event handlers\n */\n\n// APPLICATION LOGIC\n\n//const ACCOUNTS = \"http://localhost:8080\";\nconst ACCOUNTS = \"https://accounts.highfidelity.com:8080\";\n\n// There are two password-based login cycles to cover:\n// 1. Ordinary login, starting with assumed credentials from getCredential \n//    getCredential will do the right thing: ask the user to actively select\n//    a profile (with no password) if explicitly logged out, or if more than one to chose from.\n//    Otherwise just do it and notify.\n// 2. Before updating the user's (server-based) profile, starting with just an id\n//    In this case, we DO want to ask for a password, labeled by a specific profile,\n//    and we do NOT want to pick between profiles (which can happen with getCredential).\n// In either case, we want to process the login results. But if the login fails (in either case), we want to let\n// the password-request repeat (as in (2)) until success, or just ensure logOut if the user gives up.\n\nfunction callLogIn() { // case 1, above\n    const idAtStart = _highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"RegistrationStatus\"].hasRegistered();\n    return Object(_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"logIn\"])()\n        .catch(e => confirmPassword(idAtStart, e))\n        .then(c => !c && Object(_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"getUpdatedCredentials\"])({}));\n}\n\nfunction gatherCredentialForConfirmation(id) {\n    return gatherCredentialWithPassword([id], {\n        forcePassword: true,\n        forceDialog: true,\n        label: \"Confirm\"\n    });\n}\nfunction confirmPassword(id, e = null) { // case 2, above\n    // id => gather credential => login => maybe loop\n    if (e) console.warn(e);\n    return gatherCredentialForConfirmation([id])\n        .then(_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"getUpdatedCredentials\"])\n        .catch(e => confirmPassword(id, e))\n}\n\n// Asynchronously gets password and calls function({id, password}), resolving to that result.\nfunction withPassword(requestedId, functionOfCredential) {\n    // confirmPassword and call function.\n    return confirmPassword(requestedId).then(credential => {\n        if (!credential) return;\n        const {id, password} = credential;\n        if (id !== requestedId) return Promise.reject(new Error(`Changed user from ${requestedId} to ${id}.`));\n        return functionOfCredential({id, password});\n    });\n}\n\nasync function callUnregister() {\n    await initialSetUp;\n    const id = _highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"RegistrationStatus\"].id();\n    if (!id) return console.error('unregister should only be enabled for registered users.');\n    withPassword(id, cred => Object(_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"unregister\"])(cred).then(notifyLoggedOut));\n}\nfunction callPurchase({id, credits}) {\n    return withPassword(id, credential => Object(_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"purchase\"])(credential, credits));\n}\n\n// UI LOGIC\n\nfunction useClass(element, className, isOn) {\n    element.classList[isOn ? 'add' : 'remove'](className);\n}\n\n// FIXME: there are a couple of places where we should be doing MDCList.layout, but aren't. Should we use this?\nfunction openDialog(dialogDomElement, onOpen=null, stack = false) {\n    // Answer a promise that resolves to the action taken\n    const dialog = new MDCDialog(dialogDomElement);\n    // If the same dialog intermittently has buttons hidden, stack will fail unless turned off before opening.\n    dialog.autoStackButtons = stack; \n    return new Promise(resolve => {\n        const opened = onOpen && (_ => onOpen(dialog)),\n              closed = event => {\n                  resolve(event.detail.action);\n                  if (onOpen) dialog.unlisten('MDCDialog:opened', opened);\n                  dialog.unlisten('MDCDialog:closed', closed);\n              };\n        if (onOpen) dialog.listen('MDCDialog:opened', opened);\n        dialog.listen('MDCDialog:closed', closed);\n        dialog.open();\n    });\n}\nfunction goIf(from, to = '') { // set hash only if current as specified\n    if (location.hash === from) location.hash = to;\n}\n\n// Inititalizing MDC\nfunction mapSelectedElements(ancestor, selector, callback) {\n    ancestor.querySelectorAll(selector).forEach(callback);\n}\n// MDC objects are instantiated and saved so that mdcObjects.get(domElement) => MDC object.\nconst mdcObjects = new WeakMap();\nfunction instantiateDescendents(ancestor, selector, constructor) {\n    mapSelectedElements(ancestor, selector, e => mdcObjects.set(e, new constructor(e)));\n}\nfunction instantiateFields(ancestor) {\n    instantiateDescendents(ancestor, '.mdc-text-field', MDCTextField),\n    instantiateDescendents(ancestor, '.mdc-notched-outine', MDCNotchedOutline),\n    instantiateDescendents(ancestor, '.mdc-floating-label', MDCFloatingLabel),\n    instantiateDescendents(ancestor, '.mdc-text-field-helper-text', MDCTextFieldHelperText)\n}\nfunction instantiateAndLayoutLists(ancestor) {\n    mapSelectedElements(ancestor, '.mdc-list', e => {\n        const list = new MDCList(e);\n        mdcObjects.set(e, list);\n        list.layout();\n    });\n}\n/*  The Beast\nGiven a list of one or more credential ids,\npresent the user with the credentials, and\nconditionally require the user to enter the password for the selected credential.\nReturn the selected, completed credential, or falsey if the user cancels.\n\nRequires that getDb(id) produce {id, name, iconURL, password (in some conditions)}.\n\nThis is used in two circumstances:\n\n1. It implements the credentials.get UI for browsers that do not implement PasswordCredential.\n   That is, pick from among multiple credentials, or at least be made aware of the one stored credential being used.\n   If the user has explicitly signed out, then afterwards they have to explicitly pick or cancel, until they pick one.\n\n2. Regardless of whether the user experiences the above on startup vs using a native PasswordCredential, we\n   force the user to enter their (old) password before changing their profile. For example, they may\n   have walked away from the machine without logging out, or they might not have noticed the current signin\n   despite the pictures and confirmation for case (1). So before changing their profile, we force the\n   user to enter their password, without autocomplete. This is the same UI as in the singlue user case of (1),\n   because we want the user to be aware of the name, picture, and email that they are entering a password for.\n\nNow, here is where it gets tricky. I think the best user experience is where (1) is simply our own implementation \nof what Chrome does fo PasswordCredential. That's what happens by default. However, to implement (1), we keep ALL of\nthe information in our own on-device per-site persistent storage, including the password, and we don't (yet) provide\na UI for a user to manage/delete saved data, the way that the Chrome browser does for saved password credentials.\nNote that even if we did provide that, it would be in our app, not in the browser's \"settings\". It turns out that \neven in browsers that do not yet support the PasswordCredential API, they DO supply a similar separate password store.\nHowever, they require that the user click a password form field to fill in the password. Javascript cannot reach in \nand grab the password (even for our own site) without the user clicking. So... there is an alternative implementation,\nin which STORE_PASSWORDS, below, is false, in which we do not store passwords ourselves, but instead present the user\nwith the password field from (2), and let it autocomplete from the browser.\n*/\nconst STORE_PASSWORDS = !location.search.includes('store-passwords=false');\nasync function gatherCredentialWithPassword(ids, {\n    forcePassword = false,\n    forceDialog = forcePassword,\n    label = \"Sign in\",\n    message = ''} = {}) {\n    // FIXME: display message, if any (e.g., that the password entered was wrong)\n    function getIconElement(avatar) { return avatar.querySelector('img'); }\n    function getNameElement(avatar) { return avatar.querySelector('.mdc-list-item__primary-text'); }\n    function getIdElement(avatar) { return avatar.querySelector('.mdc-list-item__secondary-text'); }\n    const passwords = STORE_PASSWORDS && !forcePassword && [];\n    if (!passwords && ids.length) forceDialog = true;\n    var credential = {}, cleanup;\n    console.log('gatherCredentialWithPasswords', ids, 'dialog:', forceDialog, 'password:', forcePassword,\n                'passwords:', passwords, 'label/message:', label, message);\n\n    // Two cases where we bail early.\n    if (!ids.length) return;\n    if ((ids.length === 1) && !forceDialog) { // No need for dialog. Just a snackbar notification.\n        const cred = _highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"UserData\"].getCredential(ids[0]);\n        if (cred.password) {\n            cred.id = ids[0];\n            signingIn__label.innerText = `Signing in as ${cred.id}`;\n            signingInSnackbar.open()\n            return cred;\n        }\n    }\n\n    // Things we can set up before there is a dialog.\n    selectUser__context.innerText = label;\n    const accept = selectUser.querySelector('button[data-mdc-dialog-action=\"yes\"]');\n    if (passwords && (ids.length > 1)) {\n        accept.classList.add('hidden');\n    } else {\n        accept.querySelector('.mdc-button__label').innerText = label;\n        accept.disabled = ids.length > 1;\n        accept.classList.remove('hidden');\n    }\n    // Kludge alert:\n    // MDC listen/unlisten doesn't seem to work on this list (see cleanup), so\n    // cons a new one.\n    selectUser__list.innerHTML = '';        \n    const list = selectUser__list.cloneNode(true);\n    selectUser__list.parentNode.replaceChild(list, selectUser__list);\n\n    const confirmation = await openDialog(selectUser, dialog => {\n        const password = document.importNode(selectUserTemplate.content.lastElementChild, true),\n              passwordIndex = ids.length,\n              visibility = password.querySelector('button'),\n              input = password.querySelector('input');\n        function setCredentialFrom(index) {\n            const selected = selectUser__list.children[index];\n            credential = {\n                id: getIdElement(selected).innerText, // FIXME coming up null in store-passwords=false\n                name: getNameElement(selected).innerText,\n                iconURL: getIconElement(selected).src,\n                password: passwords ? passwords[index] : input.value,\n                type: 'password'\n            };\n        }\n        // Populate the users to select from.\n        ids.forEach(id => {\n            const data = _highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"UserData\"].getCredential(id);\n            if (!data) return console.warn(`No data for ${id}.`);\n            const {name, iconURL, password} = data;\n            const avatar = document.importNode(selectUserTemplate.content.firstElementChild, true);\n            getIconElement(avatar).src = iconURL;\n            getNameElement(avatar).innerText = name;\n            getIdElement(avatar).innerText = id;\n            if (passwords) passwords.push(password);\n            new MDCRipple(avatar);\n            selectUser__list.appendChild(avatar);\n        });\n        visibility.onclick = togglePasswordVisibility;\n        input.oninput = e => {\n            accept.disabled = !credential.id;\n            credential.password = e.target.value;\n        }\n        const nCredentials = selectUser__list.childElementCount;\n        if (forceDialog && !nCredentials) {\n            console.warn(\"No data for selecting credentials.\");\n            dialog.close();\n            Object(_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"logOut\"])({preventSilentAccess: false}).then(notifyLoggedOut);\n        } else if (nCredentials === 1) {\n            setCredentialFrom(0);\n        }\n        if (!passwords) {\n            selectUser__list.appendChild(password);\n        }\n        const fields = instantiateFields(password);\n        // Initialize the MDC list.\n        instantiateAndLayoutLists(selectUser);\n        function select({detail}) {\n            if (detail.index === passwordIndex) return;\n            accept.disabled = !input.value && !passwords;\n            setCredentialFrom(detail.index);\n            if (passwords) dialog.close('yes');\n        }\n        var selectMDC = mdcObjects.get(selectUser__list);\n        selectMDC.listen('MDCList:action', select);\n        cleanup = _ => selectMDC.unlisten('MDCList:action', select);\n    });\n    if (cleanup) cleanup();\n    if (confirmation !== 'yes') return;\n    return credential;\n}\n\nfunction reconcileLocalStorage(credential) {\n    // If a native navigator.credentials produces a credential that isn't in or local storage, add it.\n    // That way it will be available for password confirmation.\n    if (!credential) {\n        /*\n        // Kludge alert:\n        // It is possible that a security-consious user has opted out of the use of the browser's account storage,\n        // and there's no way for us to know the difference between this vs simply not choosing from among multiple browser accounts!\n        // But we can make a GUESS by comparing with our db:\n        const ids = getIds();\n        console.log('reconcileLocalStorage, ids:', ids);\n        // A security-consious user would not share a browser with other users, so if there is EXACTLY one stored in our db,\n        // it could be because the user opted out. Furthermore, if the user had not opted out (declined from multiple browser-stored\n        // choices), there ids.length would be more than 1. Finally, note that the browser-storage will not give the user\n        // a chance to decline if there's just one. So we KNOW that in this case, the user has opted out all along.\n        //\n        // I don't think this is the right thing for someone who has screwed things up by creating multiple registrations\n        // in the same OS account, and yet opting out of the browser storage. Fortunately, our face id will prevent\n        // people from accidentally doing that, so the failure case is a really twisted special special case that we simply don't support.\n        if (ids.length === 1) {\n            const cred = getDb(ids[0]);\n            if (!cred) {\n                console.warn(`Inconsistent db. No data for ${ids[0]}.`);\n                return;\n            }\n            cred.id = ids[0];\n            cred.type = 'password';\n            return cred;\n        }\n        */\n        return;\n    }\n    if (!_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"UserData\"].getCredential(credential.id)) _highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"UserData\"].storeCredential(credential);\n    return credential;\n}\nfunction filterDeletedCredential(credential) {\n    // Don't allow credentials of accounts that have been deleted by the user.\n    if (!credential) return;\n    if (credential.name === DELETED_CREDENTIAL_PROPERTY_VALUE) return;\n    return credential;\n}\n\n\nfunction notifyLoggedOut() {\n    loggedOutSnackbar.open();\n}\nfunction noteChanges(changes) {\n    console.log('changed:', ...changes);\n    // FIXME: snackbar  is just confusing things. Rip it out, or make it clearer.\n    /*\n    if (!changes.length) return;\n    const label = (changes.length > 1)\n        ? changes.slice(0, -1).join(', ') + ' and ' + changes[changes.length - 1]\n          : changes[0];\n    changed__label.innerText = `Changed ${label}.`;\n    changedSnackbar.open();\n    */\n}\n\nfunction onRegistrationStatusChange(id) {\n    const hasRegistered = _highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"RegistrationStatus\"].hasRegistered();\n    share__fieldset.disabled = buyEnergy__fieldset.disabled = forgetMe.disabled = !id;\n    const disabled = 'mdc-list-item--disabled';\n    useClass(body, 'registered', id);\n    // FIXME: there are places where we encourage people to register, that are visible when unregistered.\n    // When you have already registered, we should either hide them, or change the to encourage signing in.\n    // Exactly how to resolve this depends on whether there should be a \"sign out\" once signed in, or not.\n    useClass(registerItem, 'hidden', hasRegistered);\n    useClass(registerItem, disabled, id);\n    useClass(logoutItem, disabled, !id);\n    useClass(loginItem, disabled, id || !hasRegistered);\n}\nfunction announceArrival(hostname) {\n    console.log('arrived at', hostname);\n    guide.classList.add('hidden');\n    arrived__label.innerText = hostname ? `You have arrived near ${hostname}.` : \"You have arrived.\";\n    arrivedSnackbar.open();\n}\nfunction arriveName(name) {\n    guide.classList.add('hidden');\n    announceArrival(name);\n}\nfunction announceDeparted(hostname) {\n    console.log(hostname, 'departed');\n    arrived__label.innerText =`${hostname} is no longer present.`;\n    arrivedSnackbar.open();\n}\nfunction announceSoldOut(hostname) {\n    console.log(hostname, 'sold out');\n    arrived__label.innerText =`The invitation from ${hostname} has exceeded capacity.`;\n    arrivedSnackbar.open();\n}\nvar fixmeDemoFollowId;\nfunction onUserData(credential, destination, notedChanges) {\n    var {name, iconURL, credits, strength, demoFollowName, demoFollowId, x, y, avatar} = credential;\n    // Here we use avatar, rather than iconURL\n    if (iconURL) profile__image.src = profilemenu__image.src = iconURL;\n    if (name) demoYourOwnName.innerText = /* fixme remove <<that */profilemenu__name.innerText = name;\n    if (strength) setCurrentStrength(strength);\n    if (demoFollowName) { // FIXME remove\n        demoHostname1.innerText = demoHostname2.innerText = demoHostname3.innerText = demoHostname4.innerText =  demoFollowName;\n        fixmeDemoFollowId = demoFollowId;\n    }\n    useClass(guide, 'hidden', !destination);\n    if (destination) {\n        console.log('invite!', destination);\n        switch (destination.reason) {\n        case 'sold out':\n            announceSoldOut(destination.name);\n            guide.classList.add('hidden');\n            return credential;\n        case 'left':\n            announceDeparted(destination.name);\n            guide.classList.add('hidden');\n            return credential;\n        case 'arrived':\n            announceArrival(destination.name);\n            return credential;  // Bailing early - we're already there.\n        }\n        destinationHost.innerText = destination.name;\n        destinationLocation.innerText = `${destination.x}, ${destination.y}`;\n        yourLocation.innerText = `${x}, ${y}`;\n        setTimeout(_ => location.hash = 'destinationGuide', 100);\n    } else if (!credits) {\n        setTimeout(_ => location.hash = 'mustRegister', 100);\n    }\n    noteChanges(notedChanges);\n    return credential;\n}\nfunction onAppdrawerClosed() {\n    const activeClass = 'mdc-list-item--activated',\n          activeSelector = '.' + activeClass,\n          activeElement = appdrawer.querySelector(activeSelector);\n    if (activeElement) {\n        activeElement.classList.remove(activeClass);\n        activeElement.setAttribute('tabIndex', '-1');\n    }\n    navigationButton.blur();\n    // FIXME mainContent.querySelector('input, button').focus();\n    // Modal drawer will close when you click on scrim: fix hash without disrupting menu choices.\n    goIf('#navigation');\n}\nfunction onRegistrationSubmit(e) {\n    e.preventDefault();\n    const data = {\n        id: email.value,\n        oldEmail: oldEmail.value,\n        oldPassword: oldPassword.value,\n        name: displayName.value,\n        iconURL: face.value,\n        avatar: face.value,\n        strength: Number.parseInt(strength.value)\n    };\n    if (_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"RegistrationStatus\"].id() || !registration.classList.contains('update')) {\n        data.password = password.value; // Don't pass when updating an insecure \"account\"\n    }\n\n    Object(_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"register\"])(data).catch(e => {\n        const message = e.message || e;\n        registrationFail.innerText = message;\n        registrationFailSnackbar.open();\n        if (message.includes('email')) {\n            email.focus();\n        } else if (message.includes('selfie') || message.includes('face')) {\n            showFaceResult();\n        }\n    }).then(_ => location.hash = '');\n}\nfunction onBuyEnergy(e) {\n    e.preventDefault();\n    creditsDialog.close();\n    callPurchase({id: _highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"RegistrationStatus\"].id(), credits: Number.parseInt(purchaseAmount.value)}).catch(console.error);\n}\n\nfunction onCopyUrl() {\n    inviteUrl.select();\n    inviteUrl.setSelectionRange(0, 99999);\n    document.execCommand('copy');\n    console.log('copying', inviteUrl.value, 'to clipboard');\n}\nconst QR_CELL_SIZE = 7;\nfunction showQR(url) {\n    inviteUrl.value = url;\n    qr.className = '';\n    var generator = qrcode(0, 'H');\n    generator.addData(url);\n    generator.make();\n    qr.innerHTML = generator.createImgTag(QR_CELL_SIZE);\n}\nfunction parsedNFollowers() { return Number.parseInt(nFollowers.value || \"1\"); }\nfunction parsedFollowerCredits() { return Number.parseInt(followerCredits.value || \"10\"); }\nfunction onShareSubmit(e) {\n    e.preventDefault();\n    // Do not close: let people use the url\n    withPassword(_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"RegistrationStatus\"].id(), credential => {\n        credential.energy = parsedFollowerCredits();\n        credential.followers = parsedNFollowers();\n        Object(_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"createInvite\"])(credential).then(link => {\n            // FIXME how should this interact with back/forward button? How to get back to registerd-only?\n            showQR(new URL(link, location.href));\n            body.classList.add('shareAnyone');\n        });\n    });\n}\nfunction togglePasswordVisibility(e) {\n    e.preventDefault();\n    const icon = e.target, input = icon.previousElementSibling;\n    if (input.type === 'password') {\n        input.type = 'text';\n        icon.innerText = \"visibility_off\"\n    } else {\n        input.type = 'password';\n        icon.innerText = \"visibility\"\n    }\n}\nfunction updateFaceResult() {\n    face__image.src = face.value || '';\n    useClass(face, 'transparent', face.value);\n    useClass(face__image, 'hidden', !face.value);\n}\nfunction showFaceResult(e) {\n    if (e) e.preventDefault();\n    webcamDialog.open();\n    console.log('fixme showFaceResult');\n    Object(_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"getFace\"])(webcamVideo, videoOverlay).then(dataUrl => {\n        console.log(\"FIXME showFaceResult data:\", !!dataUrl);\n        if (webcamDialog.isOpen) webcamDialog.close();\n        if (dataUrl) {\n            face.value = dataUrl; // FIXME: in cleanup, pass this to updateFaceResult and have it do it. (But needs testing.)\n            updateFaceResult();\n        } else {\n            face.removeAttribute('required'); // FIXME: this let's user skip security selfie\n        }\n        // FIXME: also put a transparent mask over input to block clicks so that no one messes up the text\n        face.blur();\n    });\n}\n\nvar currentRegistrationDialog;\nfunction closeRegistration() { currentRegistrationDialog && currentRegistrationDialog.close(); }\nasync function openRegistration(isUpdate) {\n    await initialSetUp;\n    const registered = _highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"RegistrationStatus\"].id();\n    var credential = {};\n    if (registered) {\n        credential = await confirmPassword(registered)\n    } else if (isUpdate) {\n        credential = await Object(_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"getUpdatedCredentials\"])({});\n    }\n    if (!credential) return;\n    openDialog(registration, dialog => {\n        face.value = credential.iconURL || '';\n        displayName.value = credential.name || '';\n        oldEmail.value = email.value = credential.id || '';\n        oldPassword.value = password.value = credential.password || '';\n        strength.value = currentStrength;\n\n        // We don't want a value set in the password field when updating an unregistered \"account\", because\n        // the browser will ask to save it (confusing everyone).\n        if (registered || !isUpdate) {\n            password.setAttribute('required', true);\n        } else {\n            password.removeAttribute('required');\n        }\n        // Get the user to at least try the security selfie (but we unrequire if they explicitly skip after trying).\n        face.setAttribute('required', true);\n        console.log(\"FIXME openRegistration setting face to be required:\", face.hasAttribute('required'), `[${face.getAttribute('required')}]`, face);\n\n        useClass(registration, 'update', isUpdate);\n        register__submit.value = isUpdate ? \"Update\" : \"Register\";\n        displayName.disabled = isUpdate && _highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"EnergyMeter\"].instance.currentEnergy < 12;\n        // FIXME remove, unless we decide to prevent unregistered users from changing their strength: strength.disabled = !registered;\n\n        const fields = instantiateFields(registration);\n        const lists = instantiateAndLayoutLists(registration);\n        updateFaceResult();\n        currentRegistrationDialog = dialog;\n        dialog.listen('MDCDialog:closed', _ => {\n            currentRegistrationDialog = null;\n            goIf('#registration');\n        });\n    });\n}\n\n\n// ENERGY STUFF\n\n// var and setter in case we pull it into a module with an exposed live binding and setter.\nvar currentStrength = 1;\nfunction setCurrentStrength(strength) { currentStrength = strength; }\nvar muted = false;\nfunction setMuted(m) { muted = m; }\n\nfunction toggleMuted() {\n    setMuted(!muted);\n    toggleTalking.innerText = muted ? \"start talking\" : \"stop talking\";\n}\n\nfunction formatCredits(energy) {\n    return (energy > 1000) ? energy.toFixed() : (energy < 0.001 ? \"0.000\" : energy.toPrecision(3));\n}\nconst MAX_STRENGTH = Number.parseInt(strength.getAttribute('max')); // Consume up to N times normal rate.\nconst ENERGY_INTERVAL_MS = 100; // How often do we sample energy use.\nconst UPDATES_PER_REPORT = 15 * 1000 / ENERGY_INTERVAL_MS;  // Every 15 seconds\n\nconst AVERAGE_ENERGY_UNITS_CONSUMED_PER_HOUR = 60;\nconst INTERVALS_PER_HOUR = 60 * 60 * 1000 / ENERGY_INTERVAL_MS;\nconst AVERAGE_ENERGY_UNITS_CONSUMED_PER_INTERVAL = AVERAGE_ENERGY_UNITS_CONSUMED_PER_HOUR / INTERVALS_PER_HOUR;\nconst LINEAR_CONSUMPTION_METER_AVERAGE = 0.5;\nconst LINEAR_CONSUMPTION_METER_UNITS = AVERAGE_ENERGY_UNITS_CONSUMED_PER_INTERVAL / LINEAR_CONSUMPTION_METER_AVERAGE;\n// Sanity check: LINEAR_CONSUMPTION_METER_UNITS * LINEAR_CONSUMPTION_METER_AVERAGE * INTERVALS_PER_HOUR ~= AVERAGE_ENERGY_UNITS_CONSUMED_PER_HOUR\n\nfunction getConsumption() { // simulated\n    var meterThisPeriod = muted ? 0 : currentStrength * Math.random();\n    return Math.max(0, Math.min(_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"EnergyMeter\"].instance.currentEnergy, meterThisPeriod * LINEAR_CONSUMPTION_METER_UNITS));\n}\n     \nfunction updateEnergyDisplay(consumptionThisPeriod, currentEnergy) {\n    var scaledConsumption = (consumptionThisPeriod / LINEAR_CONSUMPTION_METER_UNITS) / MAX_STRENGTH;\n    energyBarLinearProgress.progress = scaledConsumption;\n    energy.innerText = formatCredits(currentEnergy);\n}\n\nfunction gotoHash() {\n    const hash = location.hash;\n    function is(nav) { return nav === hash; }\n    function setSheet(nav, sheet) { const should = is(nav); if (should !== sheet.open) sheet.open = should; }\n    function doDialog(nav, dialog) { is(nav) ? setTimeout(_ => dialog.open(),100) : dialog.close(); }\n    setSheet('#navigation', appdrawerDrawer);\n    setSheet('#profile', profileMenu);\n    doDialog('#energy', creditsDialog);\n    doDialog('#notImplementedIndependent', notImplementedIndependentDialog);\n    doDialog('#notImplementedDependent', notImplementedDependentDialog);\n    doDialog('#mustRegister', mustRegisterDialog);\n    doDialog('#share', shareDialog);\n    doDialog('#privacy', privacyDialog);\n    doDialog('#destinationGuide', destinationGuideDialog);\n    if (is('#registration')) {\n        openRegistration()\n    } else if (is('#changeInfo')) {\n        openRegistration(true);\n    } else {\n        closeRegistration();\n    }\n    switch (location.hash) {\n    case '#energy':\n        energyAmount.innerText = formatCredits(_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"EnergyMeter\"].instance.currentEnergy); // FIXME: Make more stand-alone, through an \"on open\" handler.\n        break;\n    case '#login':\n        callLogIn().then(_ => location.hash = '');\n        break;\n    case '#logout':\n        Object(_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"logOut\"])({preventSilentAccess: true})\n            .then(_ => location.hash = '');\n        break;\n    case '#createDemoLink':\n        Object(_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"createInvite\"])({id: fixmeDemoFollowId, password: fixmeDemoFollowId, energy: 20, followers: 100}).then(link => {\n            demoLink.href = new URL(link, location.href);\n            demoLink.innerText = demoHostPosition;\n            location.hash = '';\n        });\n        break;\n    case '#demo1':\n        moveHost({x: 100, y: 100}, \"demo link to position 1\");\n        break;\n    case '#demo2':\n        moveHost({x: 2000, y: 2000}, \"demo link to position 2\");\n        break;\n    case '#toggleTalking':\n        toggleMuted();\n        location.hash = '';\n        break;\n    case '#destinationGuide':\n        guide.blur();\n        break;\n    }\n}\nasync function moveHost(location, label) {\n    // We want to move a usr who is not us - not something that a real app would need to do.\n    // So this is pretty kludgy. First, we rely on updateUserStats() to not require password.\n    // But that sets the current energy to the value for THAT user, so we'll want to set it back.\n    var oldEnergy = _highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"EnergyMeter\"].instance.currentEnergy;\n    await Object(_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"updateUserStats\"])({id: fixmeDemoFollowId, location});\n    _highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"EnergyMeter\"].instance.currentEnergy = oldEnergy;\n    demoHostPosition = label;\n    location.hash = '';\n}\nvar demoHostPosition = \"demo link to position 1\";\n\n// GLOBALS\n\n// These would be declared differently with webpack, but still the same constants.\nconst MDCTopAppBar = mdc.topAppBar.MDCTopAppBar;\nconst MDCRipple = mdc.ripple.MDCRipple;\nconst MDCDrawer = mdc.drawer.MDCDrawer;\nconst MDCDialog = mdc.dialog.MDCDialog;\nconst MDCMenu = mdc.menu.MDCMenu;\nconst MDCList = mdc.list.MDCList;\nconst MDCSelect = mdc.select.MDCSelect;\nconst MDCTextField = mdc.textField.MDCTextField;\nconst MDCTextFieldIcon = mdc.textField.MDCTextFieldIcon;\nconst MDCTextFieldHelperText = mdc.textField.MDCTextFieldHelperText;\nconst MDCFloatingLabel = mdc.floatingLabel.MDCFloatingLabel;\nconst MDCNotchedOutline = mdc.notchedOutline.MDCNotchedOutline;\nconst MDCLinearProgress = mdc.linearProgress.MDCLinearProgress\nconst MDCSnackbar = mdc.snackbar.MDCSnackbar;\n\n// UI INITIALIZATION\n\nconst topbarTopAppBar = new MDCTopAppBar(topbar);\nconst topbarRipple = new MDCRipple(topbar);\nconst navigationButonRipple = new MDCRipple(navigationButton);\nconst copyUrlRipple = new MDCRipple(copyUrl);\nconst appdrawerDrawer = new MDCDrawer(appdrawer);\nconst privacyDialog = new MDCDialog(privacy);\nconst shareDialog = new MDCDialog(share);\nconst destinationGuideDialog = new MDCDialog(destinationGuide);\nconst notImplementedIndependentDialog = new MDCDialog(notImplementedIndependent);\nconst notImplementedDependentDialog = new MDCDialog(notImplementedDependent);\nconst mustRegisterDialog = new MDCDialog(mustRegister);\nconst creditsDialog = new MDCDialog(credits);\nconst webcamDialog = new MDCDialog(webcam);\nconst profileRipple = new MDCRipple(profile);\nconst profileMenu = new MDCMenu(profilemenu);\nconst guideRipple = new MDCRipple(guide);\n\nconst energyBarLinearProgress = new MDCLinearProgress(energyBar);\n\nconst loggedOutSnackbar = new MDCSnackbar(loggedOut);\nconst changedSnackbar = new MDCSnackbar(changed);\nconst signingInSnackbar = new MDCSnackbar(signingIn);\nconst arrivedSnackbar = new MDCSnackbar(arrived);\nconst registrationFailSnackbar = new MDCSnackbar(registrationFail);\n\nif (!window.speechSynthesis) alert('This browser does not support speech!');\nif (!navigator.mediaDevices) alert('This browser does not support webcams!');\nif ((location.protocol !== 'https:') && (location.hostname !== 'localhost')) alert('You must use https, not http!');\n\n[\n    [notImplementedIndependentDialog, 'MDCDialog:closed', '#notImplementedIndependent'],\n    [notImplementedDependentDialog, 'MDCDialog:closed', '#notImplementedDependent'],\n    [mustRegisterDialog, 'MDCDialog:closed', '#mustRegister'],\n    [privacyDialog, 'MDCDialog:closed', '#privacy'],\n    [shareDialog, 'MDCDialog:closed', '#share'],\n    [destinationGuideDialog, 'MDCDialog:closed', '#destinationGuide'],\n    [creditsDialog, 'MDCDialog:closed', '#energy'],    \n    [profileMenu, 'MDCMenuSurface:closed', '#profile']\n].forEach(([element, event, from, to = '']) => element.listen(event, _ => goIf(from, to)));\n\nwebcamDialog.listen('MDCDialog:closed', _highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"abandonFace\"]);\ndestinationGuideDialog.listen('MDCDialog:closed', ({detail}) => (detail.action === 'yes') && _highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"RegistrationStatus\"].instance.teleport());\nappdrawerDrawer.listen('MDCDrawer:closed', onAppdrawerClosed);\ncreditsDialog.listen('MDCDialog:opened', _ => {\n    const fields = instantiateFields(credits);\n    const lists = instantiateAndLayoutLists(credits);\n});\nshareDialog.listen('MDCDialog:opened', _ => {\n    const fields = instantiateFields(share);\n    const lists = instantiateAndLayoutLists(share);\n    const href = new URL(location.href);\n    href.hash = '';\n    href.searchParams.delete('invite');\n    showQR(href.href);\n});\ntopbarTopAppBar.listen('MDCTopAppBar:nav', _ => location.hash = 'navigation');\nloggedOutSnackbar.listen('MDCSnackbar:closed', ({detail}) => {\n    if (detail.reason === 'action') location.hash = 'login';\n});\nnFollowers.onchange = followerCredits.onchange = _ => inviteTotal.innerText = parsedNFollowers() * parsedFollowerCredits();\n\n[\n    [profile, 'profile'],\n    [guide, 'destinationGuide'],\n    [energyBar, 'energy']\n].forEach(([element, hash]) => element.addEventListener('click', _ => location.hash = hash));\n[\n    [passwordVisibility, togglePasswordVisibility],\n    [faceCamera, showFaceResult],\n    [face, showFaceResult],\n    [forgetMe, callUnregister],\n    [copyUrl, onCopyUrl],\n    [buyEnergy__list, _ => {!_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"RegistrationStatus\"].id() && (location.hash = 'registration');}],\n    [registrationForm, onRegistrationSubmit, 'submit'],\n    [share__form, onShareSubmit, 'submit'],\n    [buyEnergy, onBuyEnergy, 'submit'],\n    [window, gotoHash, 'hashchange']\n].forEach(([element, operation, event = 'click']) => element.addEventListener(event, operation));\n\nconst initialSetUp = Object(_highfidelity_accounts__WEBPACK_IMPORTED_MODULE_0__[\"configure\"])({\n    updateEnergyDisplay, getConsumption, accountsUrl:ACCOUNTS,\n    onRegistrationStatusChange, onUserData\n}).then(callLogIn);\ngotoHash();\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });